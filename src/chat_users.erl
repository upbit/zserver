-module(chat_users).
-behaviour(gen_server).

-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
-export([start_link/0, start_link/1, new/1, get/1, delete_all/0, stop/0]).

-define(ETS_TABLE_NAME, chat_users).
-record(state, {
	max_nick_length :: pos_integer()
}).

-spec new(binary()) -> binary() | exist.
new(Nickname) ->
	gen_server:call(?MODULE, {new, Nickname}).

-spec get(binary()) -> binary() | notfound.
get(AccessToken) ->
	gen_server:call(?MODULE, {get, AccessToken}).

-spec delete_all() -> ok.
delete_all() ->
	gen_server:cast(?MODULE, delete_all),
	ok.

-spec stop() -> ok.
stop() ->
	gen_server:cast(?MODULE, stop),
	ok.

%% gen_server functions

start_link() ->
	gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).
start_link(Options) ->
	gen_server:start_link({local, ?MODULE}, ?MODULE, Options, []).

init(Options) ->
	lager:info("~p init, options: ~p",[?ETS_TABLE_NAME, Options]),
	MaxNickLength = proplists:get_value(max_nick_length, Options, 32),
	?ETS_TABLE_NAME = ets:new(?ETS_TABLE_NAME, [set, public, {read_concurrency, true}, named_table]),
	{ok, #state{max_nick_length = MaxNickLength}}.

%% @doc Create user with Nickname, return user access token
handle_call({new, Nickname}, _From, State = #state{max_nick_length = MaxNickLength}) when size(Nickname) =< MaxNickLength ->
	AccessToken = binary:list_to_bin(to_string(uuid4())),
	true = ets:insert(?ETS_TABLE_NAME, {AccessToken, Nickname}),
	{reply, AccessToken, State};

%% @doc Search AccessToken in ETS, return nickname if exist
handle_call({get, AccessToken}, _From, State) ->
	Result = case ets:lookup(?ETS_TABLE_NAME, AccessToken) of
		[{AccessToken, Nickname}] -> Nickname;
		[] -> notfound
	end,
	{reply, Result, State}.

handle_cast(delete_all, State) ->
	true = ets:delete_all_objects(?ETS_TABLE_NAME),
	{noreply, State};

handle_cast(stop, State) ->
	{stop, {stopped, manually}, State}.

handle_info(_Info, State) ->
	{noreply, State}.

terminate(_Reason, _State) ->
	ok.

code_change(_OldVsn, State, _Extra) ->
	{ok, State}.

%% Internal functions

%
% @doc erlang-uuid
% 	https://github.com/avtobiff/erlang-uuid/blob/master/src/uuid.erl
%
%% Variant, corresponds to variant 1 0 of RFC 4122.
-define(VARIANT10, 2#10).
-define(UUIDv4, 4).

%% @doc  Create a UUID v4 (random) as a binary
-spec uuid4() -> binary().
uuid4() ->
    % Set the four most significant bits (bits 12 through 15) of the
    % time_hi_and_version field to 0100, corresponding to version 4.

    % Set the two most significant bits (bits 6 and 7) of the
    % clock_seq_hi_and_reserved to zero and one, respectively.
    % Corresponding to variant 1 0.

    % Set all other bits pseudo-randomly chosen values
    % (as generated by caller).

    <<U0:32, U1:16, _:4, U2:12, _:2, U3:30, U4:32>> = crypto:rand_bytes(16),

    <<U0:32, U1:16, ?UUIDv4:4, U2:12, ?VARIANT10:2, U3:30, U4:32>>.

%% @doc  Format UUID string from binary
-spec to_string(binary()) -> binary().
to_string(<<_:128>> = Uuid) ->
    to_string(pretty, Uuid);
to_string(_) ->
    erlang:error(badarg).

-spec to_string(simple | pretty, binary()) -> binary().
to_string(pretty, <<U0:32, U1:16, U2:16, U3:16, U4:48>>) ->
    lists:flatten(io_lib:format(
        "~8.16.0b-~4.16.0b-~4.16.0b-~4.16.0b-~12.16.0b",
        [U0, U1, U2, U3, U4]));
to_string(simple, <<S:128>>) ->
    lists:flatten(io_lib:format("~32.16.0b", [S]));
to_string(_, _) ->
    erlang:error(badarg).
